<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Integrating x11rb with an Event Loop"><meta name="keywords" content="rust, rustlang, rust-lang, event_loop_integration"><title>x11rb::event_loop_integration - Rust</title><link rel="stylesheet" type="text/css" href="../../normalize.css"><link rel="stylesheet" type="text/css" href="../../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../../light.css"  id="themeStyle"><link rel="stylesheet" type="text/css" href="../../dark.css" disabled ><link rel="stylesheet" type="text/css" href="../../ayu.css" disabled ><script id="default-settings" ></script><script src="../../storage.js"></script><script src="../../crates.js"></script><noscript><link rel="stylesheet" href="../../noscript.css"></noscript><link rel="alternate icon" type="image/png" href="../../favicon-16x16.png"><link rel="alternate icon" type="image/png" href="../../favicon-32x32.png"><link rel="icon" type="image/svg+xml" href="../../favicon.svg"><style type="text/css">#crate-search{background-image:url("../../down-arrow.svg");}</style></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu" role="button">&#9776;</div><a href='../../x11rb/index.html'><div class='logo-container rust-logo'><img src='../../rust-logo.png' alt='logo'></div></a><h2 class="location">Module event_loop_integration</h2><div class="sidebar-elems"><div id="sidebar-vars" data-name="event_loop_integration" data-ty="mod" data-relpath="./"></div><script defer src="./sidebar-items.js"></script></div></nav><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!" aria-haspopup="menu" title="themes"><img width="18" height="18" alt="Pick another theme!" src="../../brush.svg"></button><div id="theme-choices" role="menu"></div></div><nav class="sub"><form class="search-form"><div class="search-container"><div><select id="crate-search"><option value="All crates">All crates</option></select><input class="search-input" name="search" disabled autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"></div><button type="button" id="help-button" title="help">?</button><a id="settings-menu" href="../../settings.html" title="settings"><img width="18" height="18" alt="Change settings" src="../../wheel.svg"></a></div></form></nav><section id="main" class="content"><h1 class="fqn"><span class="in-band">Module <a href="../index.html">x11rb</a>::<wbr><a class="mod" href="#">event_loop_integration</a><button id="copy-path" onclick="copy_path(this)" title="Copy item path to clipboard"><img src="../../clipboard.svg" width="19" height="18" alt="Copy item path"></button></span><span class="out-of-band"><span id="render-detail"><a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class="inner">&#x2212;</span>]</a></span><a class="srclink" href="../../src/x11rb/event_loop_integration.rs.html#1-82" title="goto source code">[src]</a></span></h1><details class="rustdoc-toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><h2 id="integrating-x11rb-with-an-event-loop" class="section-header"><a href="#integrating-x11rb-with-an-event-loop">Integrating x11rb with an Event Loop</a></h2>
<p>To integrate x11rb with an event loop,
<a href="https://doc.rust-lang.org/std/os/unix/io/trait.AsRawFd.html"><code>std::os::unix::io::AsRawFd</code></a> is
implemented by <a href="../rust_connection/struct.RustConnection.html"><code>RustConnection</code></a>’s
<a href="../rust_connection/struct.DefaultStream.html#impl-AsRawFd"><code>DefaultStream</code></a> and
<a href="../xcb_ffi/struct.XCBConnection.html#impl-AsRawFd"><code>XCBConnection</code></a>. This allows to integrate
with an event loop that also handles timeouts or network I/O. See
<a href="https://github.com/psychon/x11rb/blob/master/examples/xclock_utc.rs"><code>xclock_utc</code></a> for an
example.</p>
<p>The general form of such an integration could be as follows:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">unix</span>)]</span>
<span class="kw">use</span> <span class="ident">std::os::unix::io</span>::{<span class="ident">AsRawFd</span>, <span class="ident">RawFd</span>};
<span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">windows</span>)]</span>
<span class="kw">use</span> <span class="ident">std::os::windows::io</span>::{<span class="ident">AsRawSocket</span>, <span class="ident">RawSocket</span>};
<span class="kw">use</span> <span class="ident">x11rb::connection::Connection</span>;
<span class="kw">use</span> <span class="ident">x11rb::rust_connection::RustConnection</span>;
<span class="kw">use</span> <span class="ident">x11rb::errors::ConnectionError</span>;

<span class="kw">fn</span> <span class="ident">main_loop</span>(<span class="ident">conn</span>: <span class="kw-2">&amp;</span><span class="ident">RustConnection</span>) -&gt; <span class="prelude-ty">Result</span><span class="op">&lt;</span>(), <span class="ident">ConnectionError</span><span class="op">&gt;</span> {
    <span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">unix</span>)]</span>
    <span class="kw">let</span> <span class="ident">raw_handle</span> <span class="op">=</span> <span class="ident">conn</span>.<span class="ident">stream</span>().<span class="ident">as_raw_fd</span>();
    <span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">windows</span>)]</span>
    <span class="kw">let</span> <span class="ident">raw_handle</span> <span class="op">=</span> <span class="ident">conn</span>.<span class="ident">stream</span>().<span class="ident">as_raw_socket</span>();
    <span class="kw">loop</span> {
        <span class="kw">while</span> <span class="kw">let</span> <span class="prelude-val">Some</span>(<span class="ident">event</span>) <span class="op">=</span> <span class="ident">conn</span>.<span class="ident">poll_for_event</span>()<span class="question-mark">?</span> {
            <span class="ident">handle_event</span>(<span class="ident">event</span>);
        }

        <span class="ident">poll_for_readable</span>(<span class="ident">raw_handle</span>);

        <span class="comment">// Do other work here.</span>
    }
}</code></pre></div>
<p>The function <code>poll_for_readable</code> could wait for any number of I/O streams (besides the one from
x11rb) to become readable. It can also implement timeouts, as seen in the
<a href="https://github.com/psychon/x11rb/blob/master/examples/xclock_utc.rs"><code>xclock_utc</code> example</a>.</p>
<h3 id="threads-and-races" class="section-header"><a href="#threads-and-races">Threads and Races</a></h3>
<p>Both <a href="../rust_connection/struct.RustConnection.html"><code>RustConnection</code></a> and
<a href="../xcb_ffi/struct.XCBConnection.html"><code>XCBConnection</code></a> are <code>Sync+Send</code>. However, it is still
possible to see races in the presence of threads and an event loop.</p>
<p>The underlying problem is that the following two points are not equivalent:</p>
<ol>
<li>A new event is available and can be returned from <code>conn.poll_for_event()</code>.</li>
<li>The underlying I/O stream is readable.</li>
</ol>
<p>The reason for this is an internal buffer that is required: When an event is received from the
X11 server, but we are currently not in <code>conn.poll_for_event()</code>, then this event is added to an
internal buffer. Thus, it can happen that there is an event available, but the stream is not
readable.</p>
<p>An example for such an other function is <code>conn.get_input_focus()?.reply()?</code>: The
<code>GetInputFocus</code> request is sent to the server and then <code>reply()</code> waits for the reply. It does
so by reading X11 packets from the X11 server until the right reply arrives. Any events that
are read during this are buffered internally in the <code>Connection</code>.</p>
<p>If this race occurs, the main loop would sit in <code>poll_for_readable</code> and wait, while the already
buffered event is available. When something else wakes up the main loop and
<code>conn.poll_for_event()</code> is called the next time, the event is finally processed.</p>
<p>There are two ways around this:</p>
<ol>
<li>Only interact with x11rb from one thread.</li>
<li>Use a dedicated thread for waiting for event.</li>
</ol>
<p>In case (1), one can call <code>conn.poll_for_event()</code> before waiting for the underlying I/O stream
to be readable. Since there are no other threads, nothing can read a new event from the stream
after <code>conn.poll_for_event()</code> returned <code>None</code>.</p>
<p>Option (2) is to start a thread that calls <code>conn.wait_for_event()</code> in a loop. This is basically
a dedicated event loop for fetching events from the X11 server. All other threads can now
freely use the X11 connection without events possibly getting stuck and only being processed
later.</p>
</div></details></section><section id="search" class="content hidden"></section><div id="rustdoc-vars" data-root-path="../../" data-current-crate="x11rb" data-search-index-js="../../search-index.js" data-search-js="../../search.js"></div>
    <script src="../../main.js"></script>
</body></html>