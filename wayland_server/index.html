<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="API documentation for the Rust `wayland_server` crate."><meta name="keywords" content="rust, rustlang, rust-lang, wayland_server"><title>wayland_server - Rust</title><link rel="stylesheet" type="text/css" href="../normalize.css"><link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../light.css"  id="themeStyle"><link rel="stylesheet" type="text/css" href="../dark.css" disabled ><link rel="stylesheet" type="text/css" href="../ayu.css" disabled ><script src="../storage.js"></script><noscript><link rel="stylesheet" href="../noscript.css"></noscript><link rel="shortcut icon" href="../favicon.ico"><style type="text/css">#crate-search{background-image:url("../down-arrow.svg");}</style></head><body class="rustdoc mod"><!--[if lte IE 8]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu">&#9776;</div><a href='../wayland_server/index.html'><div class='logo-container'><img src='../rust-logo.png' alt='logo'></div></a><p class='location'>Crate wayland_server</p><div class="sidebar-elems"><a id='all-types' href='all.html'><p>See all wayland_server's items</p></a><div class="block items"><ul><li><a href="#modules">Modules</a></li><li><a href="#macros">Macros</a></li><li><a href="#structs">Structs</a></li><li><a href="#enums">Enums</a></li><li><a href="#traits">Traits</a></li></ul></div><p class='location'></p><script>window.sidebarCurrent = {name: 'wayland_server', ty: 'mod', relpath: '../'};</script></div></nav><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!"><img src="../brush.svg" width="18" alt="Pick another theme!"></button><div id="theme-choices"></div></div><script src="../theme.js"></script><nav class="sub"><form class="search-form"><div class="search-container"><div><select id="crate-search"><option value="All crates">All crates</option></select><input class="search-input" name="search" disabled autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"></div><a id="settings-menu" href="../settings.html"><img src="../wheel.svg" width="18" alt="Change settings"></a></div></form></nav><section id="main" class="content"><h1 class='fqn'><span class='out-of-band'><span id='render-detail'><a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class='inner'>&#x2212;</span>]</a></span><a class='srclink' href='../src/wayland_server/lib.rs.html#1-260' title='goto source code'>[src]</a></span><span class='in-band'>Crate <a class="mod" href=''>wayland_server</a></span></h1><div class='docblock'><p>Server-side Wayland connector</p>
<h2 id="overview" class="section-header"><a href="#overview">Overview</a></h2>
<p>This crate provides the interfaces and machinery to safely create servers
for the Wayland protocol. It can be used as either a rust implementatin of the protocol,
or as a wrapper around the system-wide <code>libwayland-server.so</code> if you need interoperability
with other libraries. This last case is activated by the <code>use_system_lib</code> cargo feature.</p>
<p>The Wayland protocol revolves around the creation of various objects and the exchange
of messages associated to these objects. Whenever a client connects, a <code>Display</code> object
is automatically created in their object space, which they use as a root to create new
objects and bootstrap their state.</p>
<h2 id="protocol-and-messages-handling-model" class="section-header"><a href="#protocol-and-messages-handling-model">Protocol and messages handling model</a></h2>
<p>The protocol being bi-directional, you can send and receive messages.
Sending messages is done via methods of Rust objects corresponding to the wayland protocol
objects, receiving and handling them is done by providing callbacks.</p>
<h3 id="resources" class="section-header"><a href="#resources">Resources</a></h3>
<p>The protocol and message model is very similar to the one of <code>wayland-client</code>, with the
main difference being that the underlying handles to objects are represented by the <code>Resource&lt;I&gt;</code>
type, very similarly to proxies in <code>wayland-client</code>.</p>
<p>These resources are used to send messages to the client (in the Wayland context,
these are called &quot;events&quot;). You usually don't use them directly, and instead call
methods on the Rust objects themselves, which invoke the appropriate <code>Resource</code> methods.
It is also possible to directly use the <code>Resource::&lt;I&gt;::send(..)</code> method.</p>
<p>There is not a 1 to 1 mapping between Rust object instances and protocol
objects. Rather, you can think of the Rust objects as <code>Rc</code>-like handles to a
Wayland object. Multiple instances of a Rust object can exist referring to the same
protocol object.</p>
<p>Similarly, the lifetimes of the protocol objects and the Rust objects are
not tightly tied. As protocol objects are created and destroyed by protocol
messages, it can happen that an object gets destroyed while one or more
Rust objects still refer to it. In such case, these Rust objects will be disabled
and the <code>alive()</code> method on the underlying <code>Resource&lt;I&gt;</code> will start to return <code>false</code>.
Events that are subsequently sent to them are ignored.</p>
<h3 id="filters" class="section-header"><a href="#filters">Filters</a></h3>
<p>Your wayland objects can receive requests from the client, which need to be processed.
To do so, you can assign <code>Filter</code>s to your object. These are specially wrapped closure
so that several objects can be assigned to the same <code>Filter</code>, to ease state sharing
between the code handling different objects.</p>
<p><strong>All objects must be assigned to a filter</strong>, even if it is for doing nothing.
Failure to do will cause a <code>panic!()</code> if a request is dispatched to the faulty object.</p>
<p>A Rust object passed to your implementation is guaranteed to be alive (as it just received
a request), unless the exact message received is a destructor (which is indicated in the API
documentations).</p>
<h2 id="general-structure" class="section-header"><a href="#general-structure">General structure</a></h2>
<p>The core of your server is the <code>Display</code> object. It represent the ability of your program to
process Wayland messages. Once this object is created, you can configure it to listen on one
or more sockets for incoming client connections (see the <code>Display</code> docs for details).</p>
<p><code>wayland-server</code> does not include an event loop, and you are expected to drive the wayland socket
yourself using the <code>Display::flush_clients</code> and <code>Display::dispatch</code> methods. The <code>Display::get_poll_fd</code>
methods provides you with a file descriptor that can be used in a polling structure to integrate
the wayland socket in an event loop.</p>
</div><h2 id='modules' class='section-header'><a href="#modules">Modules</a></h2>
<table><tr class='module-item'><td><a class="mod" href="protocol/index.html" title='wayland_server::protocol mod'>protocol</a></td><td class='docblock-short'><p>Generated interfaces for the core wayland protocol</p>
</td></tr><tr class='module-item'><td><a class="mod" href="sys/index.html" title='wayland_server::sys mod'>sys</a></td><td class='docblock-short'><p>C-associated types</p>
</td></tr></table><h2 id='macros' class='section-header'><a href="#macros">Macros</a></h2>
<table><tr class='module-item'><td><a class="macro" href="macro.request_enum.html" title='wayland_server::request_enum macro'>request_enum</a></td><td class='docblock-short'><p>Generate an enum joining several objects requests</p>
</td></tr></table><h2 id='structs' class='section-header'><a href="#structs">Structs</a></h2>
<table><tr class='module-item'><td><a class="struct" href="struct.AnonymousObject.html" title='wayland_server::AnonymousObject struct'>AnonymousObject</a></td><td class='docblock-short'><p>Anonymous interface</p>
</td></tr><tr class='module-item'><td><a class="struct" href="struct.Client.html" title='wayland_server::Client struct'>Client</a></td><td class='docblock-short'><p>A handle to a client connected to your server</p>
</td></tr><tr class='module-item'><td><a class="struct" href="struct.DispatchData.html" title='wayland_server::DispatchData struct'>DispatchData</a></td><td class='docblock-short'><p>Holder of global dispatch-related data</p>
</td></tr><tr class='module-item'><td><a class="struct" href="struct.Display.html" title='wayland_server::Display struct'>Display</a></td><td class='docblock-short'><p>The wayland display</p>
</td></tr><tr class='module-item'><td><a class="struct" href="struct.Filter.html" title='wayland_server::Filter struct'>Filter</a></td><td class='docblock-short'><p>An event filter</p>
</td></tr><tr class='module-item'><td><a class="struct" href="struct.Global.html" title='wayland_server::Global struct'>Global</a></td><td class='docblock-short'><p>A handle to a global object</p>
</td></tr><tr class='module-item'><td><a class="struct" href="struct.Main.html" title='wayland_server::Main struct'>Main</a></td><td class='docblock-short'><p>A main handle to a proxy</p>
</td></tr><tr class='module-item'><td><a class="struct" href="struct.Resource.html" title='wayland_server::Resource struct'>Resource</a></td><td class='docblock-short'><p>An handle to a wayland resource</p>
</td></tr><tr class='module-item'><td><a class="struct" href="struct.UserDataMap.html" title='wayland_server::UserDataMap struct'>UserDataMap</a></td><td class='docblock-short'><p>A storage able to store several values of <code>UserData</code>
of different types. It behaves similarly to a <code>TypeMap</code>.</p>
</td></tr></table><h2 id='enums' class='section-header'><a href="#enums">Enums</a></h2>
<table><tr class='module-item'><td><a class="enum" href="enum.NoMessage.html" title='wayland_server::NoMessage enum'>NoMessage</a></td><td class='docblock-short'><p>An empty enum representing a MessageGroup with no messages</p>
</td></tr><tr class='module-item'><td><a class="enum" href="enum.ResourceMap.html" title='wayland_server::ResourceMap enum'>ResourceMap</a></td><td class='docblock-short'><p>A handle to the object map internal to the library state</p>
</td></tr></table><h2 id='traits' class='section-header'><a href="#traits">Traits</a></h2>
<table><tr class='module-item'><td><a class="trait" href="trait.Interface.html" title='wayland_server::Interface trait'>Interface</a></td><td class='docblock-short'><p>The description of a wayland interface</p>
</td></tr><tr class='module-item'><td><a class="trait" href="trait.MessageGroup.html" title='wayland_server::MessageGroup trait'>MessageGroup</a></td><td class='docblock-short'><p>A group of messages</p>
</td></tr></table></section><section id="search" class="content hidden"></section><section class="footer"></section><script>window.rootPath = "../";window.currentCrate = "wayland_server";</script><script src="../main.js"></script><script defer src="../search-index.js"></script></body></html>